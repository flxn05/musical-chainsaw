<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, viewport-fit=cover"
  />
  <title>Create Calendar Event(s) — dd/mm/yyyy + Multi-ICS</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary: #2C3E50;
      --secondary: #3498DB;
      --bg: #F4F6F8;
      --white: #fff;
      --radius: 14px;
      --muted: #6b7785;
      --danger: #e74c3c;
      --ok: #27ae60;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: var(--bg);
      color: var(--primary);
      padding: 2rem;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
    }

    .container {
      background: var(--white);
      padding: 2rem;
      border-radius: var(--radius);
      width: 100%;
      max-width: 820px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.05);
      animation: fadeInUp 0.5s ease-out;
    }

    @keyframes fadeInUp {
      from { opacity: 0; transform: translateY(16px); }
      to   { opacity: 1; transform: translateY(0); }
    }

    h1 {
      font-size: 1.8rem;
      margin-bottom: 0.25rem;
      font-weight: 700;
    }
    .subtitle { color: var(--muted); margin-bottom: 1rem; }

    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
    }
    .grid-3 {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 1rem;
    }
    .row { display: grid; gap: 1rem; }

    label {
      display: block;
      margin: 0 0 0.35rem;
      font-weight: 600;
      font-size: 0.95rem;
    }
    .optional { font-weight: 400; color: var(--muted); margin-left: .25rem; }

    input[type="text"],
    input[type="url"],
    input[type="email"],
    input[type="time"],
    textarea {
      width: 100%;
      padding: 0.8rem 0.9rem;
      border: 1px solid #d9dde3;
      border-radius: 12px;
      font-size: 1rem;
      transition: border 0.2s, box-shadow .2s;
      background: #fff;
    }
    input:focus, textarea:focus {
      outline: none;
      border-color: var(--secondary);
      box-shadow: 0 0 0 4px rgba(52, 152, 219, 0.15);
    }

    .help {
      font-size: 0.82rem;
      color: var(--muted);
      margin-top: 0.35rem;
    }

    textarea { min-height: 90px; resize: vertical; }

    .btn {
      background: var(--secondary);
      color: var(--white);
      padding: 0.9rem 1.1rem;
      border: 0;
      font-size: 1rem;
      border-radius: 12px;
      cursor: pointer;
      transition: transform .04s ease, background .2s ease;
      text-align: center;
    }
    .btn:hover { background: #2980B9; }
    .btn:active { transform: translateY(1px); }

    .btn-ghost {
      background: #eef5fb;
      color: #1b4e72;
    }
    .btn-danger {
      background: var(--danger);
    }
    .btn-success {
      background: var(--ok);
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-top: 1rem;
    }

    .card {
      border: 1px solid #e7ebf0;
      border-radius: 14px;
      padding: 1rem;
      background: #fbfdff;
    }

    .date-group {
      display: grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap: 0.75rem;
      align-items: end;
    }

    .pill {
      display: inline-flex; align-items: center; gap: .4rem;
      padding: .35rem .6rem; font-size: .8rem;
      background: #eef5fb; color: #1b4e72;
      border-radius: 999px;
    }

    .inline-note { font-size: .85rem; color: var(--muted); }
    .error { color: var(--danger); }
    .success { color: var(--ok); }

    .switch {
      position: relative; display: inline-block; width: 48px; height: 26px; vertical-align: middle;
    }
    .switch input { display:none; }
    .slider {
      position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
      background-color: #cdd7e1; transition: .2s; border-radius: 26px;
    }
    .slider:before {
      position: absolute; content: ""; height: 20px; width: 20px; left: 3px; bottom: 3px;
      background-color: white; transition: .2s; border-radius: 50%;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    input:checked + .slider { background-color: var(--secondary); }
    input:checked + .slider:before { transform: translateX(22px); }

    .flex { display: flex; align-items: center; gap: .6rem; }
    .spacer { height: 0.6rem; }

    .modal-backdrop {
      position: fixed; inset: 0; background: rgba(20,26,33,0.5);
      display: none; align-items: center; justify-content: center; padding: 1rem; z-index: 30;
    }
    .modal {
      width: 100%; max-width: 640px; background: #fff; border-radius: 16px;
      box-shadow: 0 18px 60px rgba(0,0,0,0.25); padding: 1.25rem;
      transform: translateY(10px); animation: modalIn .18s ease-out;
    }
    @keyframes modalIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .modal-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: .5rem; }
    .modal-title { font-weight: 700; font-size: 1.2rem; }
    .modal-actions { display: flex; gap: .5rem; }

    .badge {
      display: inline-block; padding: .25rem .5rem; font-size: .75rem; border-radius: 999px; background: #eef2f7; color: #3c4a59;
    }

    @media (max-width: 860px) {
      .grid, .grid-3, .date-group { grid-template-columns: 1fr; }
      body { padding: 1rem; }
      .container { padding: 1.25rem; }
      .button-row { flex-direction: column; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Create Calendar Event</h1>
    <div class="subtitle">Desktop shows a custom <span class="badge">dd/mm/yyyy</span> date input. Mobile uses the native picker.</div>

    <form id="eventForm" class="row" autocomplete="off">
      <div class="grid">
        <div>
          <label for="title">Event Title</label>
          <input type="text" id="title" name="title" required placeholder="Team sync" />
        </div>
        <div>
          <label for="location">Location<span class="optional"> (optional)</span></label>
          <input type="text" id="location" name="location" placeholder="Office HQ / Zoom" />
        </div>
      </div>

      <div>
        <label for="meetingUrl">Meeting URL<span class="optional"> (optional)</span></label>
        <input type="url" id="meetingUrl" name="meetingUrl" placeholder="https://meet.example.com/abc" />
        <div class="help">If present, it's saved as the ICS <code>URL</code>.</div>
      </div>

      <div class="grid">
        <div>
          <label for="organizerName">Organizer Name<span class="optional"> (optional)</span></label>
          <input type="text" id="organizerName" name="organizerName" placeholder="Jane Doe" />
        </div>
        <div>
          <label for="organizerEmail">Organizer Email<span class="optional"> (optional)</span></label>
          <input type="email" id="organizerEmail" name="organizerEmail" placeholder="jane@company.com" />
        </div>
      </div>

      <div>
        <label for="attendees">Attendees (emails)<span class="optional"> (optional, comma-separated)</span></label>
        <input type="text" id="attendees" name="attendees" placeholder="a@ex.com, b@ex.com" />
      </div>

      <div>
        <label for="description">Description<span class="optional"> (optional)</span></label>
        <textarea id="description" name="description" rows="3" placeholder="Agenda, notes, etc."></textarea>
      </div>

      <div class="card">
        <div class="grid">
          <div>
            <label>Start (dd/mm/yyyy + time)</label>
            <div class="date-group">
              <!-- Desktop custom date (masked) -->
              <input type="text" id="startDateText" placeholder="dd/mm/yyyy" inputmode="numeric" aria-label="Start date (dd/mm/yyyy)">
              <!-- Mobile native date (hidden on desktop) -->
              <input type="date" id="startDateNative" aria-label="Start date native" />
              <input type="time" id="startTime" required value="09:00" aria-label="Start time">
            </div>
            <div class="help"><span class="pill" id="startModePill">desktop date</span> 24h time.</div>
          </div>

          <div>
            <label>End (dd/mm/yyyy + time)</label>
            <div class="date-group">
              <input type="text" id="endDateText" placeholder="dd/mm/yyyy" inputmode="numeric" aria-label="End date (dd/mm/yyyy)">
              <input type="date" id="endDateNative" aria-label="End date native" />
              <input type="time" id="endTime" required value="09:01" aria-label="End time">
            </div>
            <div class="help">
              <span class="pill">auto +1 min</span>
              <span class="inline-note" id="autoEndNote">End auto-updates until you edit it.</span>
            </div>
          </div>
        </div>
      </div>

      <div class="spacer"></div>

      <div class="flex">
        <label class="flex" for="secondEventToggle" title="Create a second event with copied details">
          <span class="switch">
            <input type="checkbox" id="secondEventToggle">
            <span class="slider"></span>
          </span>
          <span>Add a second event</span>
        </label>
        <span class="inline-note">You’ll be prompted for the 2nd event’s title & times.</span>
      </div>

      <div class="button-row">
        <button class="btn" type="submit" id="downloadFirstBtn">Download 1st (.ics)</button>
        <button class="btn btn-ghost" type="button" id="downloadSecondBtn" disabled>Download 2nd (.ics)</button>
        <button class="btn btn-success" type="button" id="downloadAllBtn" disabled>Download All (combined .ics)</button>
      </div>

      <div id="status" class="help"></div>
    </form>
  </div>

  <!-- Modal for second event -->
  <div class="modal-backdrop" id="secondModal">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="secondTitle">
      <div class="modal-header">
        <div class="modal-title" id="secondTitle">Second Event Details</div>
        <div class="modal-actions">
          <button class="btn btn-ghost" id="cancelSecond">Cancel</button>
          <button class="btn" id="saveSecond">Save</button>
        </div>
      </div>
      <div class="row">
        <div>
          <label for="title2">Second Event Title</label>
          <input type="text" id="title2" placeholder="e.g., Follow-up meeting" />
        </div>

        <div class="grid">
          <div>
            <label>Start (dd/mm/yyyy + time)</label>
            <div class="date-group">
              <input type="text" id="startDateText2" placeholder="dd/mm/yyyy" inputmode="numeric">
              <input type="date" id="startDateNative2">
              <input type="time" id="startTime2" value="10:00">
            </div>
            <div class="help"><span class="pill" id="startModePill2">desktop date</span></div>
          </div>

          <div>
            <label>End (dd/mm/yyyy + time)</label>
            <div class="date-group">
              <input type="text" id="endDateText2" placeholder="dd/mm/yyyy" inputmode="numeric">
              <input type="date" id="endDateNative2">
              <input type="time" id="endTime2" value="10:01">
            </div>
          </div>
        </div>

        <div class="help">All other details are copied from the first event.</div>
      </div>
    </div>
  </div>

  <script>
    // --- Mobile vs Desktop detection ---
    const isLikelyMobile = () => {
      // Heuristic: touch + small width OR userAgent hints
      const touch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      const ua = navigator.userAgent.toLowerCase();
      const mobileHints = /iphone|ipad|ipod|android|mobile/.test(ua);
      return touch && (mobileHints || window.innerWidth < 900);
    };

    // --- Elements ---
    const el = id => document.getElementById(id);

    const startDateText = el('startDateText');
    const startDateNative = el('startDateNative');
    const startTime = el('startTime');

    const endDateText = el('endDateText');
    const endDateNative = el('endDateNative');
    const endTime = el('endTime');

    const startModePill = el('startModePill');

    const title = el('title');
    const description = el('description');
    const locationInput = el('location');
    const meetingUrl = el('meetingUrl');
    const organizerName = el('organizerName');
    const organizerEmail = el('organizerEmail');
    const attendees = el('attendees');

    const form = el('eventForm');
    const statusBox = el('status');

    const secondToggle = el('secondEventToggle');
    const secondModal = el('secondModal');
    const cancelSecond = el('cancelSecond');
    const saveSecond = el('saveSecond');

    const downloadFirstBtn = el('downloadFirstBtn');
    const downloadSecondBtn = el('downloadSecondBtn');
    const downloadAllBtn = el('downloadAllBtn');

    // Modal fields
    const title2 = el('title2');
    const startDateText2 = el('startDateText2');
    const startDateNative2 = el('startDateNative2');
    const startTime2 = el('startTime2');
    const endDateText2 = el('endDateText2');
    const endDateNative2 = el('endDateNative2');
    const endTime2 = el('endTime2');
    const startModePill2 = el('startModePill2');

    // State
    let usingMobile = isLikelyMobile();
    let endAuto = true; // auto-update end until user edits it
    let secondEvent = null; // {title, start, end} OR null

    // --- Helpers: date formatting & parsing (dd/mm/yyyy) ---
    const to2 = n => n.toString().padStart(2, '0');

    function maskDDMMYYYY(input) {
      // Simple input mask: dd/mm/yyyy
      let v = input.value.replace(/[^\d]/g, '');
      if (v.length > 8) v = v.slice(0, 8);
      let out = '';
      if (v.length >= 2) out = v.slice(0, 2) + '/';
      else out = v;
      if (v.length >= 4) out += v.slice(2, 4) + '/';
      else if (v.length > 2) out += v.slice(2);
      if (v.length > 4) out += v.slice(4);
      input.value = out;
    }

    function parseDDMMYYYY(str) {
      const m = /^(\d{2})\/(\d{2})\/(\d{4})$/.exec(str);
      if (!m) return null;
      const d = parseInt(m[1], 10);
      const mo = parseInt(m[2], 10);
      const y = parseInt(m[3], 10);
      if (mo < 1 || mo > 12) return null;
      if (d < 1 || d > 31) return null;
      // Construct date in local time
      const dt = new Date(y, mo - 1, d);
      if (dt.getFullYear() !== y || dt.getMonth() !== mo - 1 || dt.getDate() !== d) return null; // invalid date (e.g., 31/02)
      return dt;
    }

    function combineDateTime(dateOnly, timeHHMM) {
      const [hh, mm] = timeHHMM.split(':').map(Number);
      const dt = new Date(dateOnly);
      dt.setHours(hh || 0, mm || 0, 0, 0);
      return dt;
    }

    function formatDDMMYYYY(date) {
      return `${to2(date.getDate())}/${to2(date.getMonth()+1)}/${date.getFullYear()}`;
    }

    function ymd(date) { // yyyy-mm-dd for <input type="date">
      return `${date.getFullYear()}-${to2(date.getMonth()+1)}-${to2(date.getDate())}`;
    }

    function addMinutes(date, minutes) {
      const d = new Date(date);
      d.setMinutes(d.getMinutes() + minutes);
      return d;
    }

    function formatICSDateUTC(date) {
      // Returns UTC in ICS format: YYYYMMDDTHHMMSSZ
      const y = date.getUTCFullYear();
      const m = to2(date.getUTCMonth() + 1);
      const d = to2(date.getUTCDate());
      const hh = to2(date.getUTCHours());
      const mm = to2(date.getUTCMinutes());
      const ss = to2(date.getUTCSeconds());
      return `${y}${m}${d}T${hh}${mm}${ss}Z`;
    }

    function icsEscape(text) {
      if (text == null) return '';
      return String(text)
        .replace(/\\/g, '\\\\')
        .replace(/;/g, '\\;')
        .replace(/,/g, '\\,')
        .replace(/\r?\n/g, '\\n');
    }

    function buildVEVENT({ title, description, start, end, location, url, organizerName, organizerEmail, attendees }) {
      const lines = [];
      lines.push('BEGIN:VEVENT');
      lines.push(`UID:${Date.now()}-${Math.random().toString(36).slice(2)}@event-tool`);
      lines.push(`DTSTAMP:${formatICSDateUTC(new Date())}`);
      lines.push(`DTSTART:${formatICSDateUTC(start)}`);
      lines.push(`DTEND:${formatICSDateUTC(end)}`);
      if (title) lines.push(`SUMMARY:${icsEscape(title)}`);
      if (description) lines.push(`DESCRIPTION:${icsEscape(description)}`);
      if (location) lines.push(`LOCATION:${icsEscape(location)}`);
      if (url) lines.push(`URL:${icsEscape(url)}`);
      if (organizerEmail) {
        const cn = organizerName ? `;CN=${icsEscape(organizerName)}` : '';
        lines.push(`ORGANIZER${cn}:mailto:${icsEscape(organizerEmail)}`);
      }
      if (attendees && attendees.length) {
        attendees.forEach(email => {
          const e = email.trim();
          if (!e) return;
          lines.push(`ATTENDEE;ROLE=REQ-PARTICIPANT:mailto:${icsEscape(e)}`);
        });
      }
      lines.push('END:VEVENT');
      return lines.join('\r\n');
    }

    function buildVCALENDAR(vevents) {
      return [
        'BEGIN:VCALENDAR',
        'VERSION:2.0',
        'PRODID:-//Event Creator dd/mm/yyyy//EN',
        ...vevents,
        'END:VCALENDAR'
      ].join('\r\n');
    }

    function downloadICS(filename, content) {
      const blob = new Blob([content], { type: 'text/calendar;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // --- UI Setup: Switch date widgets based on mobile/desktop ---
    function setDateWidgetMode() {
      const desktop = !usingMobile;
      // Show/hide appropriate inputs
      startDateText.style.display = desktop ? '' : 'none';
      endDateText.style.display = desktop ? '' : 'none';
      startDateNative.style.display = desktop ? 'none' : '';
      endDateNative.style.display = desktop ? 'none' : '';
      startModePill.textContent = desktop ? 'desktop date' : 'mobile picker';
      startModePill2.textContent = desktop ? 'desktop date' : 'mobile picker';

      // Mirror initial values if empty
      const today = new Date();
      const defaultStart = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 9, 0, 0, 0);
      const defaultEnd = addMinutes(defaultStart, 1);

      if (desktop) {
        if (!startDateText.value) startDateText.value = formatDDMMYYYY(defaultStart);
        if (!endDateText.value) endDateText.value = formatDDMMYYYY(defaultEnd);
      } else {
        if (!startDateNative.value) startDateNative.value = ymd(defaultStart);
        if (!endDateNative.value) endDateNative.value = ymd(defaultEnd);
      }
      if (!startTime.value) startTime.value = '09:00';
      if (!endTime.value) endTime.value = '09:01';

      // Second modal defaults
      if (desktop) {
        if (!startDateText2.value) startDateText2.value = formatDDMMYYYY(defaultStart);
        if (!endDateText2.value) endDateText2.value = formatDDMMYYYY(defaultEnd);
      } else {
        if (!startDateNative2.value) startDateNative2.value = ymd(defaultStart);
        if (!endDateNative2.value) endDateNative2.value = ymd(defaultEnd);
      }
      if (!startTime2.value) startTime2.value = '10:00';
      if (!endTime2.value) endTime2.value = '10:01';
    }

    // Input masks for desktop date fields
    [startDateText, endDateText, startDateText2, endDateText2].forEach(inp => {
      if (!inp) return;
      inp.addEventListener('input', () => maskDDMMYYYY(inp));
      inp.addEventListener('blur', () => {
        // try to auto-complete year if user typed dd/mm/yy -> make yyyy (20yy)
        const m = /^(\d{2})\/(\d{2})\/(\d{2})$/.exec(inp.value);
        if (m) {
          const yy = parseInt(m[3], 10);
          const yyyy = yy >= 70 ? 1900 + yy : 2000 + yy;
          inp.value = `${m[1]}/${m[2]}/${yyyy}`;
        }
      });
    });

    // --- Auto end time handling ---
    function currentStartDate() {
      if (usingMobile) {
        if (!startDateNative.value) return null;
        const d = new Date(startDateNative.value);
        return isNaN(d) ? null : d;
      } else {
        return parseDDMMYYYY(startDateText.value);
      }
    }
    function currentEndDate() {
      if (usingMobile) {
        if (!endDateNative.value) return null;
        const d = new Date(endDateNative.value);
        return isNaN(d) ? null : d;
      } else {
        return parseDDMMYYYY(endDateText.value);
      }
    }

    function getStartDateTime() {
      const d = currentStartDate();
      if (!d) return null;
      if (!startTime.value) return null;
      return combineDateTime(d, startTime.value);
    }
    function getEndDateTime() {
      const d = currentEndDate();
      if (!d) return null;
      if (!endTime.value) return null;
      return combineDateTime(d, endTime.value);
    }

    function setEndFromStartPlusOneMinute() {
      const sdt = getStartDateTime();
      if (!sdt) return;
      const edt = addMinutes(sdt, 1);
      // write back to date & time
      if (usingMobile) {
        endDateNative.value = ymd(edt);
      } else {
        endDateText.value = formatDDMMYYYY(edt);
      }
      endTime.value = `${to2(edt.getHours())}:${to2(edt.getMinutes())}`;
    }

    function showStatus(msg, type='') {
      statusBox.textContent = msg;
      statusBox.className = 'help ' + (type || '');
    }

    // Start change triggers end auto-update (if endAuto)
    function onStartChanged() {
      if (endAuto) {
        setEndFromStartPlusOneMinute();
        el('autoEndNote').textContent = 'End auto-updates until you edit it.';
      }
    }

    // End edited by user -> disable auto
    function onEndEdited() {
      if (endAuto) {
        endAuto = false;
        el('autoEndNote').textContent = 'End time manually set.';
      }
    }

    // Attach listeners
    [startDateText, startDateNative, startTime].forEach(inp => {
      if (!inp) return;
      inp.addEventListener('change', onStartChanged);
      inp.addEventListener('input', onStartChanged);
    });
    [endDateText, endDateNative, endTime].forEach(inp => {
      if (!inp) return;
      inp.addEventListener('input', onEndEdited);
      inp.addEventListener('change', onEndEdited);
    });

    // --- Second event modal logic ---
    function openSecondModal() {
      // Prefill 2nd times from 1st + 60 minutes (but keep +1 min end duration)
      const s1 = getStartDateTime();
      if (s1) {
        const s2 = addMinutes(s1, 60);
        const e2 = addMinutes(s2, 1);
        if (usingMobile) {
          startDateNative2.value = ymd(s2);
          endDateNative2.value = ymd(e2);
        } else {
          startDateText2.value = formatDDMMYYYY(s2);
          endDateText2.value = formatDDMMYYYY(e2);
        }
        startTime2.value = `${to2(s2.getHours())}:${to2(s2.getMinutes())}`;
        endTime2.value = `${to2(e2.getHours())}:${to2(e2.getMinutes())}`;
      }
      title2.value = `${title.value || ''} (Part 2)`.trim();
      secondModal.style.display = 'flex';
    }
    function closeSecondModal() {
      secondModal.style.display = 'none';
    }

    secondToggle.addEventListener('change', () => {
      if (secondToggle.checked) {
        openSecondModal();
      } else {
        secondEvent = null;
        downloadSecondBtn.disabled = true;
        downloadAllBtn.disabled = true;
      }
    });
    cancelSecond.addEventListener('click', () => {
      secondToggle.checked = false;
      closeSecondModal();
      secondEvent = null;
      downloadSecondBtn.disabled = true;
      downloadAllBtn.disabled = !secondEvent;
    });

    saveSecond.addEventListener('click', () => {
      const t = title2.value.trim();
      const dStart = usingMobile
        ? (startDateNative2.value ? new Date(startDateNative2.value) : null)
        : parseDDMMYYYY(startDateText2.value);
      const dEnd = usingMobile
        ? (endDateNative2.value ? new Date(endDateNative2.value) : null)
        : parseDDMMYYYY(endDateText2.value);

      if (!t) { alert('Please enter a title for the second event.'); return; }
      if (!dStart) { alert('Please enter a valid start date for the second event (dd/mm/yyyy).'); return; }
      if (!dEnd) { alert('Please enter a valid end date for the second event (dd/mm/yyyy).'); return; }
      if (!startTime2.value || !endTime2.value) { alert('Please set start and end times for the second event.'); return; }

      const sdt = combineDateTime(dStart, startTime2.value);
      const edt = combineDateTime(dEnd, endTime2.value);
      if (edt <= sdt) { alert('Second event end must be after start.'); return; }

      secondEvent = {
        title: t,
        start: sdt,
        end: edt
      };

      downloadSecondBtn.disabled = false;
      downloadAllBtn.disabled = false;
      closeSecondModal();
      showStatus('Second event saved. You can download it or include it in the combined file.', 'success');
    });

    // Close modal on backdrop click
    secondModal.addEventListener('click', (e) => {
      if (e.target === secondModal) closeSecondModal();
    });

    // --- Build VEVENT from current form (Event #1) ---
    function buildEventFromForm() {
      const t = title.value.trim();
      if (!t) { throw new Error('Please enter a title.'); }

      const sd = currentStartDate();
      if (!sd) throw new Error('Please enter a valid start date (dd/mm/yyyy).');
      const ed = currentEndDate();
      if (!ed) throw new Error('Please enter a valid end date (dd/mm/yyyy).');

      if (!startTime.value) throw new Error('Please set a start time.');
      if (!endTime.value) throw new Error('Please set an end time.');

      const sdt = combineDateTime(sd, startTime.value);
      const edt = combineDateTime(ed, endTime.value);
      if (edt <= sdt) throw new Error('End time must be after start time.');

      // Optional fields
      const loc = locationInput.value.trim();
      const url = meetingUrl.value.trim();
      const orgName = organizerName.value.trim();
      const orgEmail = organizerEmail.value.trim();
      const attendeeList = attendees.value
        .split(',')
        .map(s => s.trim())
        .filter(Boolean);

      return {
        title: t,
        description: description.value || '',
        start: sdt,
        end: edt,
        location: loc || '',
        url: url || '',
        organizerName: orgName || '',
        organizerEmail: orgEmail || '',
        attendees: attendeeList
      };
    }

    // --- Downloads ---
    form.addEventListener('submit', (e) => {
      e.preventDefault();
      try {
        const ev = buildEventFromForm();
        const vevent = buildVEVENT(ev);
        const ics = buildVCALENDAR([vevent]);
        const safeName = (ev.title || 'event').replace(/[^\w\-]+/g, '_');
        downloadICS(`${safeName}.ics`, ics);
        showStatus('Downloaded first event.', 'success');
      } catch (err) {
        showStatus(err.message, 'error');
        alert(err.message);
      }
    });

    downloadSecondBtn.addEventListener('click', () => {
      if (!secondEvent) return;
      // Copy optional fields from first event
      let ev1;
      try { ev1 = buildEventFromForm(); } catch (e) { alert(e.message); return; }
      const ev2 = {
        title: secondEvent.title,
        description: ev1.description,
        start: secondEvent.start,
        end: secondEvent.end,
        location: ev1.location,
        url: ev1.url,
        organizerName: ev1.organizerName,
        organizerEmail: ev1.organizerEmail,
        attendees: ev1.attendees
      };
      const vevent2 = buildVEVENT(ev2);
      const ics2 = buildVCALENDAR([vevent2]);
      const safeName = (ev2.title || 'event2').replace(/[^\w\-]+/g, '_');
      downloadICS(`${safeName}.ics`, ics2);
      showStatus('Downloaded second event.', 'success');
    });

    downloadAllBtn.addEventListener('click', () => {
      if (!secondEvent) return;
      let ev1;
      try { ev1 = buildEventFromForm(); } catch (e) { alert(e.message); return; }
      const ev2 = {
        title: secondEvent.title,
        description: ev1.description,
        start: secondEvent.start,
        end: secondEvent.end,
        location: ev1.location,
        url: ev1.url,
        organizerName: ev1.organizerName,
        organizerEmail: ev1.organizerEmail,
        attendees: ev1.attendees
      };
      const v1 = buildVEVENT(ev1);
      const v2 = buildVEVENT(ev2);
      const ics = buildVCALENDAR([v1, v2]);
      const safeName = ((ev1.title || 'event') + '_and_' + (ev2.title || 'event2')).replace(/[^\w\-]+/g, '_');
      downloadICS(`${safeName}.ics`, ics);
      showStatus('Downloaded combined .ics with both events.', 'success');
    });

    // --- Initialize ---
    usingMobile = isLikelyMobile();
    setDateWidgetMode();

    // Keep end = start + 1 minute (until user changes end)
    onStartChanged();

    // Accessibility: pressing Escape closes modal
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && secondModal.style.display === 'flex') {
        closeSecondModal();
      }
    });

    // If window resizes across the heuristic boundary, we won't flip modes
    // automatically to avoid surprising the user. But you *can* enable this:
    // window.addEventListener('resize', () => {
    //   const mobileNow = isLikelyMobile();
    //   if (mobileNow !== usingMobile) {
    //     usingMobile = mobileNow;
    //     setDateWidgetMode();
    //   }
    // });
  </script>
</body>
</html>
